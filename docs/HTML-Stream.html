    <HTML>

    <HEAD>
    <TITLE></TITLE>
    </HEAD>

    <BODY>

<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#introduction_the_neapolitan_dess">INTRODUCTION (the Neapolitan dessert special)</A>
	<UL>
		<LI><A HREF="#function_interface">Function interface</A>
		<LI><A HREF="#oo_interface_vanilla">OO interface, vanilla</A>
		<LI><A HREF="#oo_interface_chocolate">OO interface, chocolate</A>
		<LI><A HREF="#oo_interface_with_whipped_cream">OO interface, with whipped cream</A>
		<LI><A HREF="#oo_interface_strawberry">OO interface, strawberry</A>
	</UL>
	<LI><A HREF="#advanced_topics">ADVANCED TOPICS</A>
	<UL>
		<LI><A HREF="#autoformatting_and_inserting_new">Auto-formatting and inserting newlines</A>
		<LI><A HREF="#entities">Entities</A>
		<LI><A HREF="#autoescaping_changing_the_way_te">Auto-escaping: changing the way text is escaped</A>
		<LI><A HREF="#outputting_html_to_things_beside">Outputting HTML to things besides filehandles</A>
		<LI><A HREF="#subclassing">Subclassing</A>
	</UL>
	<LI><A HREF="#public_interface">PUBLIC INTERFACE</A>
	<UL>
		<LI><A HREF="#functions">Functions</A>
		<LI><A HREF="#vanilla">Vanilla</A>
		<LI><A HREF="#strawberry">Strawberry</A>
		<LI><A HREF="#chocolate">Chocolate</A>
	</UL>
	<LI><A HREF="#subclasses">SUBCLASSES</A>
	<UL>
		<LI><A HREF="#htmlstreamlatin1">HTML::Stream::Latin1</A>
	</UL>
	<LI><A HREF="#performance">PERFORMANCE</A>
	<LI><A HREF="#why_in_the_world_did_i_write_thi">WHY IN THE WORLD DID I WRITE THIS?</A>
	<LI><A HREF="#change_log">CHANGE LOG</A>
	<LI><A HREF="#version">VERSION</A>
	<LI><A HREF="#acknowledgements">ACKNOWLEDGEMENTS</A>
	<LI><A HREF="#author">AUTHOR</A>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
HTML::Stream - HTML output stream class, and some markup utilities


<P>

<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
The <STRONG>HTML::Stream</STRONG>
 module provides you with an object-oriented (and subclassable) way of
outputting HTML. Basically, you open up an ``HTML stream'' on an existing
filehandle, and then do all of your output to the HTML stream. You can
intermix HTML-stream-output and ordinary-print-output, if you like.


<P>

Here's small sample of some of the non-OO ways you can use this module:


<P>

<PRE>
      use HTML::Stream qw(:funcs);
      
      print html_tag('A', HREF=&gt;$link);     
      print html_escape(&quot;&lt;&lt;Hello &amp; welcome!&gt;&gt;&quot;);      
</PRE>

<P>

And some of the OO ways as well:


<P>

<PRE>
      use HTML::Stream;
      $HTML = new HTML::Stream \*STDOUT;
      
      # The vanilla interface...
      $HTML-&gt;tag('A', HREF=&gt;&quot;$href&quot;);
      $HTML-&gt;tag('IMG', SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;);
      $HTML-&gt;text($copyright);
      $HTML-&gt;tag('_A');
      
      # The chocolate interface...
      $HTML -&gt; A(HREF=&gt;&quot;$href&quot;);
      $HTML -&gt; IMG(SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;);
      $HTML -&gt; t($caption);
      $HTML -&gt; _A;
       
      # The chocolate interface, with whipped cream...
      $HTML -&gt; A(HREF=&gt;&quot;$href&quot;)
            -&gt; IMG(SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;)
            -&gt; t($caption)
            -&gt; _A;
</PRE>

<P>

<PRE>
      # The strawberry interface...
      output $HTML [A, HREF=&gt;&quot;$href&quot;], 
                   [IMG, SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;],
                   $caption,
                   [_A];
</PRE>

<P>

There's even a small built-in subclass, <STRONG>HTML::Stream::Latin1</STRONG>
, which can handle Latin-1 input right out of the box. But all in good
time...


<P>

<P>
<HR>
<H1><A NAME="introduction_the_neapolitan_dess">INTRODUCTION (the Neapolitan dessert special)</A></H1>
<P>
<HR>
<H2><A NAME="function_interface">Function interface</A></H2>
Let's start out with the simple stuff. This module provides a collection of
non-OO utility functions for escaping HTML text and producing HTML tags,
like this:


<P>

<PRE>
    use HTML::Stream qw(:funcs);        # imports functions from @EXPORT_OK
    
    print html_tag(A, HREF=&gt;$url);
    print '&amp;copy; 1996 by', html_escape($myname), '!';
    print html_tag('/A');
</PRE>

<P>

By the way: that last line could be rewritten as:


<P>

<PRE>
    print html_tag(_A);
</PRE>

<P>

And if you need to get a parameter in your tag that doesn't have an
associated value, supply the <EM>undefined</EM>
 value (<EM>not</EM>
 the empty string!):


<P>

<PRE>
    print html_tag(TD, NOWRAP=&gt;undef, ALIGN=&gt;'LEFT');
    
         &lt;TD NOWRAP ALIGN=LEFT&gt;
    
    print html_tag(IMG, SRC=&gt;'logo.gif', ALT=&gt;'');
    
         &lt;IMG SRC=&quot;logo.gif&quot; ALT=&quot;&quot;&gt;
</PRE>

<P>

There are also some routines for reversing the process, like:


<P>

<PRE>
    $text = &quot;This &lt;i&gt;isn't&lt;/i&gt; &amp;quot;fun&amp;quot;...&quot;;    
    print html_unmarkup($text);
       
         This isn't &amp;quot;fun&amp;quot;...
      
    print html_unescape($text);
       
         This isn't &quot;fun&quot;...
</PRE>

<P>

<EM>Yeah, yeah, yeah</EM>
, I hear you cry.  <EM>We've seen this stuff before.</EM>

But wait! There's more...


<P>

<P>
<HR>
<H2><A NAME="oo_interface_vanilla">OO interface, vanilla</A></H2>
Using the function interface can be tedious... so we also provide an <STRONG>"HTML output stream"</STRONG>
 class. Messages to an instance of that class generally tell that stream to
output some HTML. Here's the above example, rewritten using HTML streams:


<P>

<PRE>
    use HTML::Stream;
    $HTML = new HTML::Stream \*STDOUT;
    
    $HTML-&gt;tag(A, HREF=&gt;$url);
    $HTML-&gt;ent('copy');
    $HTML-&gt;text(&quot; 1996 by $myname!&quot;);
    $HTML-&gt;tag(_A);
</PRE>

<P>

As you've probably guessed:


<P>

<PRE>
    text()   Outputs some text, which will be HTML-escaped.
    
    tag()    Outputs an ordinary tag, like &lt;A&gt;, possibly with parameters.
             The parameters will all be HTML-escaped automatically.
     
    ent()    Outputs an HTML entity, like the &amp;copy; or &amp;lt; .
             You mostly don't need to use it; you can often just put the 
             Latin-1 representation of the character in the text().
</PRE>

<P>

You might prefer to use <CODE>t()</CODE> and <CODE>e()</CODE> instead of <CODE>text()</CODE> 
and <CODE>ent()</CODE>: they're absolutely identical, and easier to type:


<P>

<PRE>
    $HTML -&gt; tag(A, HREF=&gt;$url);
    $HTML -&gt; e('copy');
    $HTML -&gt; t(&quot; 1996 by $myname!&quot;);
    $HTML -&gt; tag(_A);
</PRE>

<P>

Now, it wouldn't be nice to give you those <CODE>text()</CODE> and <CODE>ent()</CODE> shortcuts without giving you one for <CODE>tag()</CODE>, would it? Of course not...


<P>

<P>
<HR>
<H2><A NAME="oo_interface_chocolate">OO interface, chocolate</A></H2>
The known HTML tags are even given their own <STRONG>tag-methods,</STRONG>
 compiled on demand. The above code could be written even more compactly as:


<P>

<PRE>
    $HTML -&gt; A(HREF=&gt;$url);
    $HTML -&gt; e('copy');
    $HTML -&gt; t(&quot; 1996 by $myname!&quot;);
    $HTML -&gt; _A;
</PRE>

<P>

As you've probably guessed:


<P>

<PRE>
    A(HREF=&gt;$url)   ==   tag(A, HREF=&gt;$url)   ==   &lt;A HREF=&quot;/the/url&quot;&gt;
    _A              ==   tag(_A)              ==   &lt;/A&gt;
</PRE>

<P>

All of the autoloaded ``tag-methods'' use the tagname in <EM>all-uppercase</EM>
. A <CODE>"_"</CODE> prefix on any tag-method means that an end-tag is desired. The <CODE>"_"</CODE> was chosen for several reasons: (1) it's short and easy to type, (2) it
doesn't produce much visual clutter to look at, (3) <CODE>_TAG</CODE> looks a little like <CODE>/TAG</CODE> because of the straight line.


<P>

<UL>
<LI><STRONG></STRONG>
<EM>I know, I know... it looks like a private method.
You get used to it.  Really.</EM>





<P>

</UL>
I should stress that this module will only auto-create tag methods for <STRONG>known</STRONG>
 HTML tags. So you're protected from typos like this (which will cause a
fatal exception at run-time):


<P>

<PRE>
    $HTML -&gt; IMGG(SRC=&gt;$src);
</PRE>

<P>

(You're not yet protected from illegal tag parameters, but it's a start,
ain't it?)


<P>

If you need to make a tag known (sorry, but this is currently a 
<EM>global</EM>
 operation, and not stream-specific), do this:


<P>

<PRE>
    accept_tag HTML::Stream 'MARQUEE';       # for you MSIE fans...
</PRE>

<P>

<STRONG>Note: there is no corresponding "reject_tag".</STRONG>
  I thought and thought about it, and could not convince myself that such a
method would do anything more useful than cause other people's modules to
suddenly stop working because some bozo function decided to reject the <CODE>FONT</CODE> tag.


<P>

<P>
<HR>
<H2><A NAME="oo_interface_with_whipped_cream">OO interface, with whipped cream</A></H2>
In the grand tradition of C++, output method chaining is supported in both
the Vanilla Interface and the Chocolate Interface. So you can (and probably
should) write the above code as:


<P>

<PRE>
    $HTML -&gt; A(HREF=&gt;$url) 
          -&gt; e('copy') -&gt; t(&quot; 1996 by $myname!&quot;) 
          -&gt; _A;
</PRE>

<P>

<EM>But wait!  Neapolitan ice cream has one more flavor...</EM>





<P>

<P>
<HR>
<H2><A NAME="oo_interface_strawberry">OO interface, strawberry</A></H2>
I was jealous of the compact syntax of HTML::AsSubs, but I didn't want to
worry about clogging the namespace with a lot of functions like
<CODE>p(),</CODE> <CODE>a(),</CODE> etc. (especially when markup-functions
like <CODE>tr()</CODE> conflict with existing Perl functions). So I came up
with this:


<P>

<PRE>
    output $HTML [A, HREF=&gt;$url], &quot;Here's my $caption&quot;, [_A];
</PRE>

<P>

Conceptually, arrayrefs are sent to <CODE>html_tag()</CODE>, and strings to 
<CODE>html_escape()</CODE>.


<P>

<P>
<HR>
<H1><A NAME="advanced_topics">ADVANCED TOPICS</A></H1>
<P>
<HR>
<H2><A NAME="autoformatting_and_inserting_new">Auto-formatting and inserting newlines</A></H2>
<EM>Auto-formatting</EM>
 is the name I give to the Chocolate Interface feature whereby newlines (and
maybe, in the future, other things) are inserted before or after the tags
you output in order to make your HTML more readable. So, by default, this:


<P>

<PRE>
    $HTML -&gt; HTML 
          -&gt; HEAD  
          -&gt; TITLE -&gt; t(&quot;Hello!&quot;) -&gt; _TITLE 
          -&gt; _HEAD
          -&gt; BODY(BGCOLOR=&gt;'#808080');
</PRE>

<P>

Actually produces this:


<P>

<PRE>
    &lt;HTML&gt;&lt;HTML&gt;
    &lt;HEAD&gt;
    &lt;TITLE&gt;Hello!&lt;/TITLE&gt;
    &lt;/HEAD&gt;
    &lt;BODY BGCOLOR=&quot;#808080&quot;&gt;
</PRE>

<P>

<STRONG>To turn off autoformatting altogether</STRONG>
 on a given HTML::Stream object, use the <CODE>auto_format()</CODE> method:


<P>

<PRE>
    $HTML-&gt;auto_format(0);        # stop autoformatting!
</PRE>

<P>

<STRONG>To change whether a newline is automatically output</STRONG>
 before/after the begin/end form of a tag at a <STRONG>global</STRONG>
 level, use <CODE>set_tag()</CODE>:


<P>

<PRE>
    HTML::Stream-&gt;set_tag('B', Newlines=&gt;15);   # 15 means &quot;\n&lt;B&gt;\n \n&lt;/B&gt;\n&quot;
    HTML::Stream-&gt;set_tag('I', Newlines=&gt;7);    # 7 means  &quot;\n&lt;I&gt;\n \n&lt;/I&gt;  &quot;
</PRE>

<P>

<STRONG>To change whether a newline is automatically output</STRONG>
 before/after the begin/end form of a tag <STRONG>for a given stream</STRONG>
 level, give the stream its own private ``tag info'' table, and then use <CODE>set_tag()</CODE>:


<P>

<PRE>
    $HTML-&gt;private_tags;
    $HTML-&gt;set_tag('B', Newlines=&gt;0);     # won't affect anyone else!
</PRE>

<P>

<STRONG>To output newlines explicitly</STRONG>
, just use the special <CODE>nl</CODE> method in the Chocolate Interface:


<P>

<PRE>
    $HTML-&gt;nl;     # one newline
    $HTML-&gt;nl(6);  # six newlines
</PRE>

<P>

I am sometimes asked, ``why don't you put more newlines in automatically?''
Well, mostly because...


<P>

<UL>
<LI><STRONG></STRONG>
Sometimes you'll be outputting stuff inside a <CODE>PRE</CODE> environment.


<P>

<LI><STRONG></STRONG>
Sometimes you really do want to jam things (like images, or table cell
delimiters and the things they contain) right up against each other.


<P>

</UL>
So I've stuck to outputting newlines in places where it's most likely to be
harmless. 


<P>

<P>
<HR>
<H2><A NAME="entities">Entities</A></H2>
As shown above, You can use the <CODE>ent()</CODE> (or <CODE>e()</CODE>) method to output an entity:


<P>

<PRE>
    $HTML-&gt;t('Copyright ')-&gt;e('copy')-&gt;t(' 1996 by Me!');
</PRE>

<P>

But this can be a pain, particularly for generating output with non-ASCII
characters:


<P>

<PRE>
    $HTML -&gt; t('Copyright ') 
          -&gt; e('copy') 
          -&gt; t(' 1996 by Fran') -&gt; e('ccedil') -&gt; t('ois, Inc.!');
</PRE>

<P>

Granted, Europeans can always type the 8-bit characters directly in their
Perl code, and just have this:


<P>

<PRE>
    $HTML -&gt; t(&quot;Copyright \251 1996 by Fran\347ois, Inc.!');
</PRE>

<P>

But folks without 8-bit text editors can find this kind of output
cumbersome to generate. Sooooooooo...


<P>

<P>
<HR>
<H2><A NAME="autoescaping_changing_the_way_te">Auto-escaping: changing the way text is escaped</A></H2>
<EM>Auto-escaping</EM>
 is the name I give to the act of taking an ``unsafe'' string (one with
``>'', ``&'', etc.), and magically outputting ``safe'' HTML.


<P>

The default ``auto-escape'' behavior of an HTML stream can be a drag if
you've got a lot character entities that you want to output, or if you're
using the Latin-1 character set, or some other input encoding. Fortunately,
you can use the <CODE>auto_escape()</CODE> method to change the way a particular HTML::Stream works at any time.


<P>

First, here's a couple of special invocations:


<P>

<PRE>
    $HTML-&gt;auto_escape('ALL');      # Default; escapes [&lt;&gt;&quot;&amp;] and 8-bit chars.
    $HTML-&gt;auto_escape('LATIN_1');  # Like ALL, but uses Latin-1 entities
                                    #   instead of decimal equivalents.
    $HTML-&gt;auto_escape('NON_ENT');  # Like ALL, but leaves &quot;&amp;&quot; alone.
</PRE>

<P>

You can also install your own auto-escape function (note that you might
very well want to install it for just a little bit only, and then
de-install it):


<P>

<PRE>
    sub my_auto_escape {
        my $text = shift;
	HTML::Entities::encode($text);     # start with default
        $text =~ s/\(c\)/&amp;copy;/ig;        # (C) becomes copyright
        $text =~ s/\\,(c)/\&amp;$1cedil;/ig;   # \,c becomes a cedilla
 	$text;
    }
    
    # Start using my auto-escape:
    my $old_esc = $HTML-&gt;auto_escape(\&amp;my_auto_escape);  
    
    # Output some stuff:
    $HTML-&gt; IMG(SRC=&gt;'logo.gif', ALT=&gt;'Fran\,cois, Inc');
    output $HTML 'Copyright (C) 1996 by Fran\,cois, Inc.!';
    
    # Stop using my auto-escape:
    $HTML-&gt;auto_escape($old_esc);
</PRE>

<P>

If you find yourself in a situation where you're doing this a lot, a better
way is to create a <STRONG>subclass</STRONG>
 of HTML::Stream which installs your custom function when constructed. For
an example, see the 
<STRONG>HTML::Stream::Latin1</STRONG>
 subclass in this module.


<P>

<P>
<HR>
<H2><A NAME="outputting_html_to_things_beside">Outputting HTML to things besides filehandles</A></H2>
As of Revision 1.21, you no longer need to supply <CODE>new()</CODE> with a filehandle: <EM>any object that responds to a print() method will do</EM>
. Of course, this includes <STRONG>blessed</STRONG>
 FileHandles, and IO::Handles.


<P>

If you supply a GLOB reference (like <CODE>\*STDOUT</CODE>) or a string (like
<CODE>"Module::FH"</CODE>), HTML::Stream will automatically create an invisible object for talking
to that filehandle (I don't dare bless it into a FileHandle, since the
underlying descriptor would get closed when the HTML::Stream is destroyed,
and you might not want that).


<P>

You say you want to print to a string? For kicks and giggles, try this:


<P>

<PRE>
    package StringHandle;
    sub new {
	my $self = '';
	bless \$self, shift;
    }
    sub print {
        my $self = shift;
        $$self .= join('', @_);
    }
    
  
    package main;
    use HTML::Stream;
    
    my $SH = new StringHandle;
    my $HTML = new HTML::Stream $SH;
    $HTML -&gt; H1 -&gt; &quot;&lt;Hello &amp; welcome!&gt;&quot; -&gt; _H1;
    print &quot;PRINTED STRING: &quot;, $$SH, &quot;\n&quot;;
</PRE>

<P>

<P>
<HR>
<H2><A NAME="subclassing">Subclassing</A></H2>
This is where you can make your application-specific HTML-generating code
<EM>much</EM>
 easier to look at. Consider this:


<P>

<PRE>
    package MY::HTML;
    @ISA = qw(HTML::Stream);
     
    sub Aside {
	$_[0] -&gt; FONT(SIZE=&gt;-1) -&gt; I;
    }
    sub _Aside {
	$_[0] -&gt; _I -&gt; _FONT;
    }
</PRE>

<P>

Now, you can do this:


<P>

<PRE>
    my $HTML = new MY::HTML \*STDOUT;
    
    $HTML -&gt; Aside
          -&gt; t(&quot;Don't drink the milk, it's spoiled... pass it on...&quot;)
          -&gt; _Aside;
</PRE>

<P>

If you're defining these markup-like, chocolate-interface-style functions,
I recommend using mixed case with a leading capital. You probably shouldn't
use all-uppercase, since that's what this module uses for real HTML tags.


<P>

<P>
<HR>
<H1><A NAME="public_interface">PUBLIC INTERFACE</A></H1>
<P>
<HR>
<H2><A NAME="functions">Functions</A></H2>
<DL>
<DT><STRONG><A NAME="item_html_escape_text">html_escape TEXT

</A></STRONG><DD>
Given a TEXT string, turn the text into valid HTML by escaping ``unsafe''
characters. Currently, the ``unsafe'' characters are 8-bit characters plus:


<P>

<PRE>
    &lt;  &gt;  =  &amp;
</PRE>

<P>

<STRONG>Note:</STRONG>
 provided for convenience and backwards-compatibility only. You may want to
use the more-powerful <STRONG>HTML::Entities::encode</STRONG>

function instead.


<P>

<DT><STRONG><A NAME="item_html_tag_tag_paramvalue">html_tag TAG [, PARAM=>VALUE, ...]

</A></STRONG><DD>
Return the text for a given TAG, possibly with parameters. As an efficiency
hack, only the values are HTML-escaped currently: it is assumed that the
tag and parameters will already be safe.


<P>

For convenience and readability, you can say <CODE>_A</CODE> instead of <CODE>"/A"</CODE>
for the first tag, if you're into barewords.


<P>

<DT><STRONG><A NAME="item_html_unescape_text">html_unescape TEXT

</A></STRONG><DD>
Remove angle-tag markup, and convert the standard ampersand-escapes (<CODE>lt</CODE>, <CODE>gt</CODE>, <CODE>amp</CODE>, <CODE>quot</CODE>, and <CODE>#ddd</CODE>) into ASCII characters.


<P>

<STRONG>Note:</STRONG>
 provided for convenience and backwards-compatibility only. You may want to
use the more-powerful <STRONG>HTML::Entities::decode</STRONG>

function instead: unlike this function, it can collapse entities like <CODE>copy</CODE> and <CODE>ccedil</CODE> into their Latin-1 byte values.


<P>

<DT><STRONG><A NAME="item_html_unmarkup_text">html_unmarkup TEXT

</A></STRONG><DD>
Remove angle-tag markup from TEXT, but do not convert ampersand-escapes.
Cheesy, but theoretically useful if you want to, say, incorporate
externally-provided HTML into a page you're generating, and are worried
that the HTML might contain undesirable markup.


<P>

</DL>
<P>
<HR>
<H2><A NAME="vanilla">Vanilla</A></H2>
<DL>
<DT><STRONG><A NAME="item_new_printable">new [PRINTABLE] 

</A></STRONG><DD>
<EM>Class method.</EM>

Create a new HTML output stream.


<P>

The PRINTABLE may be a FileHandle, a glob reference, or any object that
responds to a <CODE>print()</CODE> message. If no PRINTABLE is given, does a <CODE>select()</CODE> and uses
that.


<P>

<DT><STRONG><A NAME="item_auto_escape_namesubref">auto_escape [NAME|SUBREF]

</A></STRONG><DD>
<EM>Instance method.</EM>

Set the auto-escape function for this HTML stream.


<P>

If the argument is a subroutine reference SUBREF, then that subroutine will
be used. Declare such subroutines like this:


<P>

<PRE>
    sub my_escape {
	my $text = shift;     # it's passed in the first argument
        ...
        $text;
    }
</PRE>

<P>

If a textual NAME is given, then one of the appropriate built-in functions
is used. Possible values are:


<P>

<DL>
<DT><STRONG><A NAME="item_all">ALL

</A></STRONG><DD>
Default for HTML::Stream objects. This escapes angle brackets, ampersands,
double-quotes, and 8-bit characters. 8-bit characters are escaped using
decimal entity codes (like <CODE>#123</CODE>).


<P>

<DT><STRONG><A NAME="item_latin_1">LATIN_1

</A></STRONG><DD>
Like <A HREF="#item_all">ALL</A>, but uses Latin-1 entity names (like <CODE>ccedil</CODE>) instead of decimal entity codes to escape characters. This makes the HTML
more readable but it is currently not advised, as ``older'' browsers (like
Netscape 2.0) do not recognize many of the ISO-8859-1 entity names (like <CODE>deg</CODE>).


<P>

<STRONG>Warning:</STRONG>
 If you specify this option, you'll find that it attempts to ``require'' <STRONG>HTML::Entities</STRONG>
 at run time. That's because I didn't want to <EM>force</EM>
 you to have that module just to use the rest of HTML::Stream. To pick up
problems at compile time, you are advised to say:


<P>

<PRE>
    use HTML::Stream;
    use HTML::Entities;
</PRE>

<P>

in your source code.


<P>

<DT><STRONG><A NAME="item_non_ent">NON_ENT

</A></STRONG><DD>
Like <A HREF="#item_all">ALL</A>, except that ampersands (&) are <EM>not</EM>
 escaped. This allows you to use &-entities in your text strings, while
having everything else safely escaped:


<P>

<PRE>
    output $HTML &quot;If A is an acute angle, then A &gt; 90&amp;deg;&quot;;
</PRE>

<P>

</DL>
Returns the previously-installed function, in the manner of <CODE>select()</CODE>. No arguments just returns the currently-installed function.


<P>

<DT><STRONG><A NAME="item_auto_format_onoff">auto_format ONOFF

</A></STRONG><DD>
<EM>Instance method.</EM>

Set the auto-formatting characteristics for this HTML stream. Currently,
all you can do is supply a single defined boolean argument, which turns
auto-formatting ON (1) or OFF (0). The self object is returned.


<P>

Please use no other values; they are reserved for future use.


<P>

<DT><STRONG><A NAME="item_comment_comment">comment COMMENT

</A></STRONG><DD>
<EM>Instance method.</EM>

Output an HTML comment. As of 1.29, a newline is automatically appended.


<P>

<DT><STRONG><A NAME="item_ent_entity">ent ENTITY

</A></STRONG><DD>
<EM>Instance method.</EM>

Output an HTML entity. For example, here's how you'd output a non-breaking
space:


<P>

<PRE>
      $html-&gt;ent('nbsp');
</PRE>

<P>

You may abbreviate this method name as <CODE>e</CODE>:


<P>

<PRE>
      $html-&gt;e('nbsp');
</PRE>

<P>

<STRONG>Warning:</STRONG>
 this function assumes that the entity argument is legal.


<P>

<DT><STRONG><A NAME="item_nl_count">nl [COUNT]

</A></STRONG><DD>
<EM>Instance method.</EM>

Output COUNT newlines. If undefined, COUNT defaults to 1.


<P>

<DT><STRONG><A NAME="item_tag_tagname_paramvalue">tag TAGNAME [, PARAM=>VALUE, ...]

</A></STRONG><DD>
<EM>Instance method.</EM>

Output a tag. Returns the self object, to allow method chaining. You can
say <CODE>_A</CODE> instead of <CODE>"/A"</CODE>, if you're into barewords.


<P>

<DT><STRONG><A NAME="item_text_text_text">text TEXT, ..., TEXT

</A></STRONG><DD>
<EM>Instance method.</EM>

Output some text. Returns the self object, to allow method chaining. You
may abbreviate this method name as <CODE>t</CODE>:


<P>

<PRE>
      $html-&gt;t('Hi there, ', $yournamehere, '!');
</PRE>

<P>

</DL>
<P>
<HR>
<H2><A NAME="strawberry">Strawberry</A></H2>
<DL>
<DT><STRONG><A NAME="item_output_itemitem">output ITEM,...,ITEM

</A></STRONG><DD>
<EM>Instance method.</EM>

Go through the items. If an item is an arrayref, treat it like the array
argument to <CODE>html_tag()</CODE> and output the result. If an item is a
text string, escape the text and output the result. Like this:


<P>

<PRE>
     output $HTML [A, HREF=&gt;$url], &quot;Here's my $caption!&quot;, [_A];
</PRE>

<P>

</DL>
<P>
<HR>
<H2><A NAME="chocolate">Chocolate</A></H2>
<DL>
<DT><STRONG><A NAME="item_accept_tag_tag">accept_tag TAG

</A></STRONG><DD>
<EM>Class method.</EM>

Declares that the tag is to be accepted as valid HTML (if it isn't
already). For example, this...


<P>

<PRE>
     # Make sure methods MARQUEE and _MARQUEE are compiled on demand:
     HTML::Stream-&gt;accept_tag('MARQUEE'); 
</PRE>

<P>

...gives the Chocolate Interface permission to create (via AUTOLOAD)
definitions for the MARQUEE and _MARQUEE methods, so you can then say:


<P>

<PRE>
     $HTML -&gt; MARQUEE -&gt; t(&quot;Hi!&quot;) -&gt; _MARQUEE;
</PRE>

<P>

If you want to set the default attribute of the tag as well, you can do so
via the <CODE>set_tag()</CODE> method instead; it will effectively do an
<CODE>accept_tag()</CODE> as well.


<P>

<PRE>
     # Make sure methods MARQUEE and _MARQUEE are compiled on demand,
     #   *and*, set the characteristics of that tag.
     HTML::Stream-&gt;set_tag('MARQUEE', Newlines=&gt;9);
</PRE>

<P>

<DT><STRONG><A NAME="item_private_tags">private_tags 

</A></STRONG><DD>
<EM>Instance method.</EM>

Normally, HTML streams use a reference to a global table of tag information
to determine how to do such things as auto-formatting, and modifications
made to that table by <CODE>set_tag</CODE> will affect everyone.


<P>

However, if you want an HTML stream to have a private copy of that table to
munge with, just send it this message after creating it. Like this:


<P>

<PRE>
    my $HTML = new HTML::Stream \*STDOUT;
    $HTML-&gt;private_tags;
</PRE>

<P>

Then, you can say stuff like:


<P>

<PRE>
    $HTML-&gt;set_tag('PRE',   Newlines=&gt;0);
    $HTML-&gt;set_tag('BLINK', Newlines=&gt;9);
</PRE>

<P>

And it won't affect anyone else's <EM>auto-formatting</EM>
 (although they will possibly be able to use the BLINK tag method without a
fatal exception <CODE>:-(</CODE> ).


<P>

Returns the self object.


<P>

<DT><STRONG><A NAME="item_set_tag_tag_taginfo">set_tag TAG, [TAGINFO...]

</A></STRONG><DD>
<EM>Class/instance method.</EM>

Accept the given TAG in the Chocolate Interface, and (if TAGINFO is given)
alter its characteristics when being output.


<P>

<UL>
<LI><STRONG></STRONG>
<STRONG>If invoked as a class method,</STRONG>
 this alters the ``master tag table'', and allows a new tag to be supported
via an autoloaded method:


<P>

<PRE>
     HTML::Stream-&gt;set_tag('MARQUEE', Newlines=&gt;9);
</PRE>

<P>

Once you do this, <EM>all</EM>
 HTML streams you open from then on will allow that tag to be output in the
chocolate interface.


<P>

<LI><STRONG></STRONG>
<STRONG>If invoked as an instance method,</STRONG>
 this alters the ``tag table'' referenced by that HTML stream, usually for
the purpose of affecting things like the auto-formatting on that HTML
stream.  


<P>

<STRONG>Warning:</STRONG>
 by default, an HTML stream just references the ``master tag table'' (this
makes <CODE>new()</CODE> more efficient), so <EM>by default, the 
instance method will behave exactly like the class method.</EM>





<P>

<PRE>
     my $HTML = new HTML::Stream \*STDOUT;
     $HTML-&gt;set_tag('BLINK', Newlines=&gt;0);  # changes it for others!
</PRE>

<P>

If you want to diddle with <EM>one</EM>
 stream's auto-formatting <EM>only,</EM>
 
you'll need to give that stream its own <EM>private</EM>
 tag table. Like this:


<P>

<PRE>
     my $HTML = new HTML::Stream \*STDOUT;
     $HTML-&gt;private_tags;
     $HTML-&gt;set_tag('BLINK', Newlines=&gt;0);  # doesn't affect other streams
</PRE>

<P>

<STRONG>Note:</STRONG>
 this will still force an default entry for BLINK in the <EM>master</EM>
 
tag table: otherwise, we'd never know that it was legal to AUTOLOAD a BLINK
method. However, it will only alter the <EM>characteristics</EM>
 of the BLINK tag (like auto-formatting) in the <EM>object's</EM>
 tag table.


<P>

</UL>
The TAGINFO, if given, is a set of key=>value pairs with the following
possible keys:


<P>

<DL>
<DT><STRONG><A NAME="item_newlines">Newlines

</A></STRONG><DD>
Assumed to be a number which encodes how newlines are to be output
before/after a tag. The value is the logical OR (or sum) of a set of flags:


<P>

<PRE>
     0x01    newline before &lt;TAG&gt;         .&lt;TAG&gt;.     .&lt;/TAG&gt;.    
     0x02    newline after &lt;TAG&gt;          |     |     |      |
     0x04    newline before &lt;/TAG&gt;        1     2     4      8
     0x08    newline after &lt;/TAG&gt;    
</PRE>

<P>

Hence, to output BLINK environments which are preceded/followed by
newlines:


<P>

<PRE>
     set_tag HTML::Stream 'BLINK', Newlines=&gt;9;
</PRE>

<P>

</DL>
Returns the self object on success.


<P>

<DT><STRONG><A NAME="item_tags">tags 

</A></STRONG><DD>
<EM>Class/instance method.</EM>

Returns an unsorted list of all tags in the class/instance tag table (see <CODE>set_tag</CODE> for class/instance method differences).


<P>

</DL>
<P>
<HR>
<H1><A NAME="subclasses">SUBCLASSES</A></H1>
<P>
<HR>
<H2><A NAME="htmlstreamlatin1">HTML::Stream::Latin1</A></H2>
A small, public package for outputting Latin-1 markup. Its default
auto-escape function is <A HREF="#item_latin_1">LATIN_1</A>, which tries to output the mnemonic entity markup (e.g., <CODE>&ccedil;</CODE>) for ISO-8859-1 characters.


<P>

So using HTML::Stream::Latin1 like this:


<P>

<PRE>
    use HTML::Stream;
    
    $HTML = new HTML::Stream::Latin1 \*STDOUT;
    output $HTML &quot;\253A right angle is 90\260, \277No?\273\n&quot;;
</PRE>

<P>

Prints this:


<P>

<PRE>
    &amp;laquo;A right angle is 90&amp;deg;, &amp;iquest;No?&amp;raquo;
</PRE>

<P>

Instead of what HTML::Stream would print, which is this:


<P>

<PRE>
    &amp;#171;A right angle is 90&amp;#176;, &amp;#191;No?&amp;#187;
</PRE>

<P>

<STRONG>Warning:</STRONG>
 a lot of Latin-1 HTML markup is not recognized by older browsers (e.g.,
Netscape 2.0). Consider using HTML::Stream; it will output the decimal
entities which currently seem to be more ``portable''.


<P>

<STRONG>Note:</STRONG>
 using this class ``requires'' that you have HTML::Entities.


<P>

<P>
<HR>
<H1><A NAME="performance">PERFORMANCE</A></H1>
Slower than I'd like. Both the <CODE>output()</CODE> method and the various
``tag'' methods seem to run about 5 times slower than the old
just-hardcode-the-darn stuff approach. That is, in general, this:


<P>

<PRE>
    ### Approach #1...
    tag  $HTML 'A', HREF=&gt;&quot;$href&quot;;
    tag  $HTML 'IMG', SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;;
    text $HTML $caption;
    tag  $HTML '_A';
    text $HTML $a_lot_of_text;
</PRE>

<P>

And this:


<P>

<PRE>
    ### Approach #2...
    output $HTML [A, HREF=&gt;&quot;$href&quot;], 
	         [IMG, SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;],
		 $caption,
		 [_A];
    output $HTML $a_lot_of_text;
</PRE>

<P>

And this:


<P>

<PRE>
    ### Approach #3...
    $HTML -&gt; A(HREF=&gt;&quot;$href&quot;)
	  -&gt; IMG(SRC=&gt;&quot;logo.gif&quot;, ALT=&gt;&quot;LOGO&quot;)
	  -&gt; t($caption)
	  -&gt; _A
          -&gt; t($a_lot_of_text);
</PRE>

<P>

Each run about 5x slower than this:


<P>

<PRE>
    ### Approach #4...
    print '&lt;A HREF=&quot;', html_escape($href), '&gt;',
          '&lt;IMG SRC=&quot;logo.gif&quot; ALT=&quot;LOGO&quot;&gt;',
  	  html_escape($caption),
          '&lt;/A&gt;';
    print html_escape($a_lot_of_text);
</PRE>

<P>

Of course, I'd much rather use any of first three <EM>(especially #3)</EM>
 
if I had to get something done right in a hurry. Or did you not notice the
typo in approach #4?  <CODE>;-)</CODE>




<P>

(BTW, thanks to Benchmark:: for allowing me to... er... benchmark stuff.)


<P>

<P>
<HR>
<H1><A NAME="why_in_the_world_did_i_write_thi">WHY IN THE WORLD DID I WRITE THIS?</A></H1>
I was just mucking about with different ways of generating large HTML
documents, seeing which ways I liked the most/least.


<P>

<P>
<HR>
<H1><A NAME="change_log">CHANGE LOG</A></H1>
<DL>
<DT><STRONG><A NAME="item_version_131">Version 1.31

</A></STRONG><DD>
<STRONG>NEW TOOL for generating Perl code which uses HTML::Stream!</STRONG>
 
Check yor toolkit for <STRONG>html2perlstream</STRONG>
.


<P>

Added built-in support for escaping 8-bit characters.


<P>

Added <A HREF="#item_latin_1">LATIN_1</A> auto-escape, which uses HTML::Entities to generate mnemonic entities. This
is now the default method for HTML::Stream::Latin1.


<P>

Added <CODE>auto_format(),</CODE> 
so you can now turn auto-formatting off/on.


<P>

Added <A HREF="#item_private_tags">private_tags</A>, so it is now possible for HTML streams to each have their own ``private''
copy of the <CODE>%Tags</CODE> table, for use by <CODE>set_tag()</CODE>.


<P>

Added <CODE>set_tag()</CODE>. The tags tables may now be modified dynamically so as to change how
formatting is done on-the-fly. This will hopefully not compromise the
efficiency of the chocolate interface (until now, the formatting was
compiled into the method itself), and <EM>will</EM>
 add greater flexibility for more-complex programs.


<P>

Added POD documentation for all subroutines in the public interface.


<P>

<DT><STRONG><A NAME="item_version_129">Version 1.29

</A></STRONG><DD>
Added terminating newline to <CODE>comment().</CODE>
<EM>Thanks to John D Groenveld for the suggestion and the patch.</EM>





<P>

<DT><STRONG><A NAME="item_version_127">Version 1.27

</A></STRONG><DD>
Added built-in HTML::Stream::Latin1, which does a very simple encoding of
all characters above ASCII 127.


<P>

Fixed bug in <CODE>accept_tag(),</CODE> where 'my' variable was shadowing
argument.
<EM>Thanks to John D Groenveld for the bug report and the patch.</EM>





<P>

<DT><STRONG><A NAME="item_version_126">Version 1.26 

</A></STRONG><DD>
Start of history.


<P>

</DL>
<P>
<HR>
<H1><A NAME="version">VERSION</A></H1>
$Revision: 1.32 $


<P>

<P>
<HR>
<H1><A NAME="acknowledgements">ACKNOWLEDGEMENTS</A></H1>
Warmest thanks to...


<P>

<PRE>
    John Buckman           For suggesting that I write an &quot;html2perlstream&quot;,
                           and inspiring me to look at supporting Latin-1.
    Tony Cebzanov          For suggesting that I write an &quot;html2perlstream&quot;
    John D Groenveld       Bug reports, patches, and suggestions
    B. K. Oxley (binkley)  For suggesting the support of &quot;writing to strings&quot;
                           which became the &quot;printable&quot; interface.
</PRE>

<P>

<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
Eryq, <A HREF="MAILTO:eryq@enteract.com">eryq@enteract.com</A> or <A
HREF="MAILTO:eryq@rhine.gsfc.nasa.gov">eryq@rhine.gsfc.nasa.gov</A> or
thereabouts.


<P>

Enjoy.


<P>

    </BODY>

    </HTML>
